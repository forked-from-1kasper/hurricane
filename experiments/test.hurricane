module test where

def id (A : U) : U := A
def idfun (A : U) (a : A) : A := a

def ∘ (A B C : U) (f : B → C) (g : A → B) : A → C := λ (x : A), f (g x)

def Path (A : U) (a b : A) := PathP (λ (i : I), A) a b

def ρ (i j : I) := coe (λ (x : I), Path I left x) j (<_> left) @ i

def meet (i j : I) :=
coe (λ (i : I), PathP (λ (j : I), Path I left (ρ i j))
  (<_> left) (<j> ρ i j)) right (<_ _> left) @ i @ j

def join (i j : I) :=
coe (λ (i : I), PathP (λ (j : I), Path I (meet i j) i)
  (<k> meet i k) (<_> i)) right (<_ _> left) @ i @ j

def conn-∧ (A : U) (a b : A) (p : Path A a b) (i : I) : Path A a (p @ i) :=
<j> p @ meet i j

def conn-∨ (A : U) (a b : A) (p : Path A a b) (i : I) : Path A (p @ i) b :=
<j> p @ join i j

def Iso (A B : U) :=
Σ (f : A → B) (g : B → A), (Π (x : A), Path A (g (f x)) x) × (Π (x : B), Path B (f (g x)) x)

def Iso→Path (A B : U) (e : Iso A B) : PathP (λ (_ : I), U) A B :=
<i> iso A B e.1 e.2.1 e.2.2.1 e.2.2.2 i

def coe-Iso (A B : U) (e : Iso A B) (x : A) :
  Path B (coe (λ (i : I), Iso→Path A B e @ i) right x) (e.1 x) :=
<_> e.1 x
